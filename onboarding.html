<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>JobSprint Onboarding</title>

  <!-- Font & Style -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="styles/theme.css" />
  <style>
    *{box-sizing:border-box}
    body{margin:0;font-family:'Inter',system-ui,-apple-system,'Segoe UI',sans-serif;color:var(--ink);background:transparent;overflow-x:hidden}
    .floating{position:absolute;background:rgba(13,110,253,0.12);border-radius:50%;animation:float 14s ease-in-out infinite;pointer-events:none;z-index:0}
    .floating:nth-of-type(1){width:160px;height:160px;top:12vh;left:8vw}
    .floating:nth-of-type(2){width:110px;height:110px;bottom:12vh;right:12vw;animation-delay:-4s}
    .floating:nth-of-type(3){width:90px;height:90px;top:48vh;right:24vw;animation-delay:-8s}
    @keyframes float{0%,100%{transform:translate3d(0,0,0)}50%{transform:translate3d(14px,-18px,0)}}
    .page-shell{position:relative;z-index:1;max-width:var(--shell-max-width,880px);margin:0 auto;padding:72px 24px 120px}
    .stage-card{background:rgba(255,255,255,0.9);border-radius:28px;border:1px solid rgba(10,102,194,0.16);box-shadow:var(--shadow-sm);padding:48px 56px;margin-bottom:32px;backdrop-filter:blur(12px)}
    .stage-card header{margin-bottom:24px}
    h1{margin:0;font-size:30px;font-weight:700;color:var(--ink)}
    p.sub{margin:8px 0 0;color:var(--muted);font-size:15px;line-height:1.6}
    label{display:block;margin:18px 0 8px;font-weight:600;color:var(--ink)}
    textarea{resize:vertical;min-height:110px}
    .field-hint{font-size:13px;color:var(--muted);margin-top:6px}
    .field-hint a{color:var(--brand);text-decoration:none}
    .field-hint a:hover{text-decoration:underline}
    .field-error{font-size:13px;color:#d93025;margin-top:6px}
    .combobox-field{position:relative}
    .combobox-input-wrapper{position:relative;display:flex;align-items:center}
    .combobox-input{width:100%;padding:12px 44px 12px 14px;border-radius:14px;border:1px solid rgba(10,102,194,0.16);background:rgba(255,255,255,0.92);font-size:15px;transition:border-color .2s ease,box-shadow .2s ease;box-shadow:var(--shadow-xs,0 6px 20px rgba(10,102,194,0.08))}
    .combobox-input:focus{outline:none;border-color:var(--brand);box-shadow:0 0 0 3px rgba(10,102,194,0.18)}
    .combobox-input-wrapper::after{content:'';position:absolute;right:16px;top:50%;margin-top:-2px;border-width:6px 5px 0 5px;border-style:solid;border-color:var(--muted) transparent transparent transparent;transition:transform .2s ease}
    .combobox-field[data-open='true'] .combobox-input-wrapper::after{transform:rotate(180deg);margin-top:-4px}
    .combobox-list{position:absolute;z-index:20;top:calc(100% + 6px);left:0;right:0;max-height:260px;overflow-y:auto;border-radius:14px;background:#fff;border:1px solid rgba(10,102,194,0.16);box-shadow:0 22px 48px rgba(10,102,194,0.14);list-style:none;margin:0;padding:6px 0;display:none}
    .combobox-field[data-open='true'] .combobox-list{display:block}
    .combobox-option{padding:10px 16px;font-size:15px;cursor:pointer;line-height:1.4}
    .combobox-option[aria-selected='true']{font-weight:600}
    .combobox-option.is-active,.combobox-option:hover{background:rgba(10,102,194,0.08)}
    .combobox-option.is-selected{color:var(--brand-strong)}
    .combobox-group{padding:8px 16px 6px;font-size:12px;font-weight:600;text-transform:uppercase;letter-spacing:0.08em;color:var(--muted)}
    .combobox-no-results{padding:12px 16px;font-size:14px;color:var(--muted)}
    .combobox-hint{margin-top:10px}
    .tag-field{position:relative}
    .tag-input-wrapper{display:flex;flex-wrap:wrap;align-items:center;gap:8px;padding:10px 12px;border-radius:14px;border:1px solid rgba(10,102,194,0.16);background:rgba(255,255,255,0.92);min-height:48px;transition:border-color .2s ease,box-shadow .2s ease}
    .tag-field:focus-within .tag-input-wrapper{border-color:var(--brand);box-shadow:0 0 0 3px rgba(10,102,194,0.18)}
    .tag-chips{display:flex;flex-wrap:wrap;gap:8px;margin:0;padding:0}
    .tag-chips:empty::before{content:'No cities selected yet';color:var(--muted);font-size:14px}
    .tag-chip{display:inline-flex;align-items:center;background:rgba(10,102,194,0.12);color:var(--brand-strong);border-radius:999px;padding:6px 10px;font-size:13px;font-weight:600}
    .tag-chip button{border:none;background:transparent;color:inherit;margin-left:6px;cursor:pointer;font-size:14px;line-height:1;display:inline-flex;align-items:center;justify-content:center;width:18px;height:18px;border-radius:50%;transition:background .2s ease}
    .tag-chip button:hover{background:rgba(10,102,194,0.18)}
    .tag-input-wrapper input{flex:1 0 180px;border:none;outline:none;background:transparent;font-size:15px;min-width:150px;padding:6px 0}
    .tag-input-wrapper input:disabled{cursor:not-allowed;color:var(--muted)}
    .tag-options{position:absolute;z-index:20;top:calc(100% + 6px);left:0;right:0;max-height:240px;overflow-y:auto;border-radius:14px;background:#fff;border:1px solid rgba(10,102,194,0.16);box-shadow:0 22px 48px rgba(10,102,194,0.14);list-style:none;margin:0;padding:6px 0;display:none}
    .tag-field[data-open='true'] .tag-options{display:block}
    .tag-option{padding:10px 16px;font-size:15px;cursor:pointer;line-height:1.4}
    .tag-option.is-active,.tag-option:hover{background:rgba(10,102,194,0.08)}
    .tag-option[data-selected='true']{color:var(--brand-strong);font-weight:600}
    .tag-option.is-info{color:var(--muted);cursor:default}
    .tag-field[data-maxed='true'] .tag-input-wrapper{opacity:0.78}
    .tag-field[data-maxed='true'] .tag-options{display:none !important}
    .actions{display:flex;gap:12px;margin-top:32px;flex-wrap:wrap}
    .primary-btn{background:linear-gradient(135deg,var(--brand),var(--brand-accent));color:#fff;border:none;border-radius:14px;padding:12px 22px;font-weight:600;font-size:15px;cursor:pointer;box-shadow:var(--shadow-sm);transition:transform .2s ease,box-shadow .2s ease}
    .primary-btn:hover{transform:translateY(-1px);box-shadow:0 18px 32px rgba(10,102,194,0.2)}
    .ghost-btn{background:rgba(255,255,255,0.85);color:var(--brand-strong);border:1px solid rgba(10,102,194,0.16);border-radius:14px;padding:12px 22px;font-weight:600;font-size:15px;cursor:pointer;transition:background .2s ease,box-shadow .2s ease}
    .ghost-btn:hover{background:rgba(10,102,194,0.08);box-shadow:0 10px 22px rgba(10,102,194,0.12)}
    .back-to-workspace{position:fixed;top:24px;right:24px;background:rgba(255,255,255,0.92);color:var(--brand-strong);border:1px solid rgba(10,102,194,0.2);border-radius:999px;padding:10px 18px;font-weight:600;font-size:13px;cursor:pointer;box-shadow:var(--shadow-sm);z-index:10;transition:transform .2s ease,box-shadow .2s ease}
    .back-to-workspace:hover{transform:translateY(-1px);box-shadow:0 16px 30px rgba(10,102,194,0.18)}
    .hidden{display:none}
    .step-indicator{text-align:right;font-size:13px;color:var(--muted);margin-bottom:24px;font-weight:600}
    .footer-note{text-align:center;font-size:13px;color:var(--muted);margin-top:24px}
    .section-title{margin-top:32px;font-size:18px;font-weight:700;color:var(--ink)}
    .dual-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:18px}
    @media(max-width:720px){.stage-card{padding:36px 24px}.dual-grid{grid-template-columns:1fr}.back-to-workspace{right:16px} .page-shell{padding-top:110px}}
  </style>
</head>
<body>

  <header class="app-navbar" role="banner">
    <a class="app-navbar__logo" href="index.html">
      <img src="logo.png" alt="JobSprint logo" loading="lazy" />
      <span>JobSprint</span>
    </a>
    <nav class="app-navbar__nav" aria-label="Primary navigation">
      <a class="app-navbar__link" href="workspace.html">Workspace</a>
      <a class="app-navbar__link" href="mailto:hello@jobsprint.ai">Support</a>
    </nav>
  </header>

  <button id="backToWorkspace" class="back-to-workspace hidden">‚Üê Back to workspace</button>

  <!-- floating doodles -->
  <div class="floating" style="animation-delay:0s;"></div>
  <div class="floating" style="animation-delay:-4s;"></div>
  <div class="floating" style="animation-delay:-8s;"></div>

  <div class="page-shell">
  <section class="stage-card animate-fade" id="step1">
    <div class="step-indicator">Step 1 of 2</div>
    <h1>Let‚Äôs start with your basics üå±</h1>
    <p class="sub">Upload your resume and I‚Äôll fill what I can. You can edit anything anytime.</p>

    <label>Upload Resume (PDF/DOCX)</label>
    <input type="file" id="resume_file" accept=".pdf,.doc,.docx" />
    <div id="resumeStatus" class="field-hint"></div>

    <label>Full Name</label>
    <input type="text" id="name" placeholder="Your full name" />

    <label>Email</label>
    <input type="email" id="email" placeholder="you@example.com" />

    <label>Phone</label>
    <input type="text" id="phone" placeholder="+91 9876543210" />

    <label>Date of Birth</label>
    <input type="date" id="dob" />

    <label for="roleInput">Current Role</label>
    <div class="combobox-field" id="roleCombobox">
      <input type="hidden" id="role" value="" />
      <div class="combobox-input-wrapper">
        <input
          id="roleInput"
          class="combobox-input"
          type="text"
          role="combobox"
          aria-autocomplete="list"
          aria-expanded="false"
          aria-haspopup="listbox"
          aria-controls="roleList"
          placeholder="Select or search your current role"
          autocomplete="off"
          spellcheck="false"
        />
      </div>
      <ul id="roleList" class="combobox-list" role="listbox" tabindex="-1"></ul>
      <p class="field-hint combobox-hint">Start typing to search, or enter your own title.</p>
    </div>

    <label>Total Experience (years)</label>
    <input type="number" id="experience" min="0" step="0.1" placeholder="e.g., 5.5" />

    <label for="currentCTC">Current CTC</label>
    <input
      type="number"
      id="currentCTC"
      inputmode="numeric"
      pattern="[0-9]*"
      min="0"
      step="1"
      placeholder="e.g., 1800000"
      aria-describedby="currentCTCHint currentCTCError"
    />
    <p class="field-hint" id="currentCTCHint">Enter digits only, e.g., 1800000 for ‚Çπ18L.</p>
    <p class="field-error hidden" id="currentCTCError" aria-live="polite"></p>

    <label for="preferredCitySearch">Preferred cities</label>
    <div class="tag-field" id="preferredCityField">
      <div class="tag-input-wrapper">
        <div class="tag-chips" id="preferredCitySelected" aria-live="polite"></div>
        <input
          type="text"
          id="preferredCitySearch"
          placeholder="Start typing to search cities"
          autocomplete="off"
          aria-autocomplete="list"
          aria-expanded="false"
          aria-haspopup="listbox"
          aria-controls="preferredCityOptions"
          aria-describedby="preferredCityHint preferredCityError"
        />
      </div>
      <ul id="preferredCityOptions" class="tag-options" role="listbox" aria-multiselectable="true"></ul>
    </div>
    <p class="field-hint" id="preferredCityHint">Select up to 3 preferred cities. Leave blank if you're flexible or open to remote roles.</p>
    <p class="field-error hidden" id="preferredCityError" aria-live="polite"></p>

    <div class="actions">
      <button id="nextBtn" class="primary-btn" type="button">Next: Tell your story ‚Üí</button>
    </div>
  </section>

  <section class="stage-card hidden animate-fade" id="step2">
    <div class="step-indicator">Step 2 of 2</div>
    <h1>Now, let‚Äôs talk about <em>you</em> üåª</h1>
    <p class="sub">Don‚Äôt overthink ‚Äî just answer from the heart.</p>

    <label>Your career story so far</label>
    <textarea id="journey" placeholder="How did you get where you are today?"></textarea>

    <label>Your top 2‚Äì3 strengths</label>
    <textarea id="strengths" placeholder="e.g., curiosity, discipline, creativity"></textarea>

    <label>Work that energizes you</label>
    <textarea id="flow" placeholder="What kind of problems do you love solving?"></textarea>

    <label>Your next role / dream job</label>
    <textarea id="nextRole" placeholder="What do you want to do next?"></textarea>

    <label>Your long-term career vision</label>
    <textarea id="vision" placeholder="How do you see yourself growing in 5 years?"></textarea>

    <div class="actions">
      <button id="backBtn" class="ghost-btn" type="button">‚Üê Back</button>
      <button id="finishBtn" class="primary-btn" type="button">Finish Setup</button>
    </div>
  </section>

  <p class="footer-note">We believe every job seeker deserves structure, clarity, and calm. üå§Ô∏è</p>
  </div>

  <script src="scripts/theme.js"></script>
  <script>
    const params = new URLSearchParams(location.search);
    let googleId = params.get('google_id');
    const paymentId = params.get('payment_id');
    const finishBtn = document.getElementById('finishBtn');
    const roleHiddenInput = document.getElementById('role');
    const roleInputEl = document.getElementById('roleInput');
    const roleListEl = document.getElementById('roleList');
    const roleCombobox = document.getElementById('roleCombobox');
    const backToWorkspaceBtn = document.getElementById('backToWorkspace');
    const currentCTCInput = document.getElementById('currentCTC');
    const currentCTCErrorEl = document.getElementById('currentCTCError');
    const preferredCityField = document.getElementById('preferredCityField');
    const preferredCityInput = document.getElementById('preferredCitySearch');
    const preferredCityOptionsEl = document.getElementById('preferredCityOptions');
    const preferredCitySelectedEl = document.getElementById('preferredCitySelected');
    const preferredCityErrorEl = document.getElementById('preferredCityError');

    const maxPreferredCities = 3;
    const curatedPreferredCities = [
      'Bengaluru',
      'Hyderabad',
      'Mumbai',
      'Delhi NCR',
      'Pune',
      'Chennai',
      'Gurugram',
      'Noida',
      'Kolkata',
      'Ahmedabad',
      'Jaipur',
      'Chandigarh',
      'Kochi',
      'Coimbatore',
      'Indore',
      'Surat',
      'Nagpur',
      'Goa',
      'Remote (Open to anywhere)'
    ];

    const normalizeCityString = (value = '') => {
      if (value === null || value === undefined) return '';
      return value
        .toString()
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .replace(/&/g, 'and')
        .replace(/[^a-z0-9]+/g, ' ')
        .trim();
    };

    const sanitizeCityValue = (value) => {
      if (typeof value !== 'string') return null;
      const cleaned = value.replace(/\s+/g, ' ').trim();
      return cleaned ? cleaned : null;
    };

    const curatedPreferredCityMeta = curatedPreferredCities.map((value) => ({
      value,
      normalized: normalizeCityString(value)
    }));

    let selectedPreferredCities = [];
    let preferredCityFilteredOptions = [];
    let preferredCityActiveIndex = -1;
    let preferredCityDropdownOpen = false;

    const setPreferredCityError = (message) => {
      if (!preferredCityErrorEl) return;
      const text = typeof message === 'string' ? message.trim() : '';
      preferredCityErrorEl.textContent = text;
      if (text) {
        preferredCityErrorEl.classList.remove('hidden');
      } else {
        preferredCityErrorEl.classList.add('hidden');
      }
    };

    const highlightPreferredCityOption = (index) => {
      if (!preferredCityInput) {
        preferredCityActiveIndex = -1;
        return;
      }
      if (!preferredCityFilteredOptions.length || index < 0 || index >= preferredCityFilteredOptions.length) {
        preferredCityFilteredOptions.forEach(({ element }) => {
          element.classList.remove('is-active');
        });
        preferredCityInput.removeAttribute('aria-activedescendant');
        preferredCityActiveIndex = -1;
        return;
      }
      preferredCityFilteredOptions.forEach(({ element }, idx) => {
        if (idx === index) {
          element.classList.add('is-active');
          element.scrollIntoView({ block: 'nearest' });
          preferredCityInput.setAttribute('aria-activedescendant', element.id);
        } else {
          element.classList.remove('is-active');
        }
      });
      preferredCityActiveIndex = index;
    };

    const openPreferredCityDropdown = () => {
      if (!preferredCityField || !preferredCityInput) return;
      if (selectedPreferredCities.length >= maxPreferredCities) return;
      preferredCityField.setAttribute('data-open', 'true');
      preferredCityInput.setAttribute('aria-expanded', 'true');
      preferredCityDropdownOpen = true;
    };

    const closePreferredCityDropdown = () => {
      if (!preferredCityField || !preferredCityInput) return;
      preferredCityField.removeAttribute('data-open');
      preferredCityInput.setAttribute('aria-expanded', 'false');
      preferredCityDropdownOpen = false;
      highlightPreferredCityOption(-1);
    };

    const updatePreferredCityInputState = () => {
      if (!preferredCityInput || !preferredCityField) return;
      const maxed = selectedPreferredCities.length >= maxPreferredCities;
      preferredCityInput.disabled = maxed;
      preferredCityInput.placeholder = maxed
        ? `Maximum of ${maxPreferredCities} cities selected`
        : 'Start typing to search cities';
      preferredCityField.setAttribute('data-maxed', maxed ? 'true' : 'false');
      preferredCityInput.setAttribute('aria-expanded', !maxed && preferredCityDropdownOpen ? 'true' : 'false');
      if (maxed) {
        closePreferredCityDropdown();
      }
    };

    const renderPreferredCityChips = () => {
      if (!preferredCitySelectedEl) return;
      preferredCitySelectedEl.innerHTML = '';
      selectedPreferredCities.forEach((city) => {
        const chip = document.createElement('span');
        chip.className = 'tag-chip';
        chip.textContent = city;
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.setAttribute('aria-label', `Remove ${city}`);
        removeBtn.innerHTML = '&times;';
        removeBtn.addEventListener('click', () => {
          removePreferredCity(city);
          preferredCityInput?.focus();
        });
        chip.appendChild(removeBtn);
        preferredCitySelectedEl.appendChild(chip);
      });
    };

    const renderPreferredCityOptions = (query = '') => {
      if (!preferredCityOptionsEl) return;
      const normalizedQuery = normalizeCityString(query);
      preferredCityOptionsEl.innerHTML = '';
      preferredCityFilteredOptions = [];

      if (selectedPreferredCities.length >= maxPreferredCities) {
        closePreferredCityDropdown();
        return;
      }

      const selectedKeys = new Set(
        selectedPreferredCities.map((city) => normalizeCityString(city)).filter(Boolean)
      );

      const matches = curatedPreferredCityMeta.filter((option) => {
        if (selectedKeys.has(option.normalized)) return false;
        if (!normalizedQuery) return true;
        if (option.normalized.includes(normalizedQuery)) return true;
        const tokens = normalizedQuery.split(' ').filter(Boolean);
        if (!tokens.length) return true;
        return tokens.every((token) => option.normalized.includes(token));
      });

      matches.forEach((option, index) => {
        const li = document.createElement('li');
        li.className = 'tag-option';
        li.dataset.value = option.value;
        li.dataset.index = String(index);
        li.id = `preferred-city-option-${index}`;
        li.setAttribute('role', 'option');
        li.textContent = option.value;
        preferredCityFilteredOptions.push({ value: option.value, element: li });
        preferredCityOptionsEl.appendChild(li);
      });

      if (!preferredCityFilteredOptions.length) {
        const empty = document.createElement('li');
        empty.className = 'tag-option is-info';
        empty.setAttribute('role', 'presentation');
        const trimmed = query && query.trim();
        empty.textContent = trimmed
          ? `Press Enter to add ‚Äú${trimmed}‚Äù.`
          : 'No cities found.';
        preferredCityOptionsEl.appendChild(empty);
      }

      if (preferredCityFilteredOptions.length || (query && query.trim())) {
        openPreferredCityDropdown();
      } else {
        closePreferredCityDropdown();
      }

      highlightPreferredCityOption(-1);
    };

    const dedupePreferredCities = (cities) => {
      const seen = new Set();
      const result = [];
      cities.forEach((value) => {
        const sanitized = sanitizeCityValue(value);
        if (!sanitized) return;
        const key = normalizeCityString(sanitized);
        if (!key || seen.has(key)) return;
        seen.add(key);
        result.push(sanitized);
      });
      return result;
    };

    const addPreferredCity = (city) => {
      const sanitized = sanitizeCityValue(city);
      if (!sanitized) {
        preferredCityInput && (preferredCityInput.value = '');
        return;
      }
      const key = normalizeCityString(sanitized);
      if (selectedPreferredCities.some((existing) => normalizeCityString(existing) === key)) {
        preferredCityInput && (preferredCityInput.value = '');
        setPreferredCityError('');
        closePreferredCityDropdown();
        return;
      }
      if (selectedPreferredCities.length >= maxPreferredCities) {
        setPreferredCityError(`You can pick up to ${maxPreferredCities} cities.`);
        closePreferredCityDropdown();
        return;
      }
      selectedPreferredCities = [...selectedPreferredCities, sanitized];
      preferredCityInput && (preferredCityInput.value = '');
      setPreferredCityError('');
      renderPreferredCityChips();
      updatePreferredCityInputState();
      renderPreferredCityOptions('');
      closePreferredCityDropdown();
    };

    const removePreferredCity = (city) => {
      const key = normalizeCityString(city);
      selectedPreferredCities = selectedPreferredCities.filter(
        (existing) => normalizeCityString(existing) !== key
      );
      renderPreferredCityChips();
      updatePreferredCityInputState();
      if (preferredCityDropdownOpen || (preferredCityInput && document.activeElement === preferredCityInput)) {
        renderPreferredCityOptions(preferredCityInput?.value || '');
      } else if (preferredCityOptionsEl && !preferredCityDropdownOpen) {
        preferredCityOptionsEl.innerHTML = '';
        preferredCityFilteredOptions = [];
        preferredCityActiveIndex = -1;
        preferredCityInput?.removeAttribute('aria-activedescendant');
      }
      setPreferredCityError('');
    };

    const commitPreferredCityInput = () => {
      if (!preferredCityInput) return;
      const value = preferredCityInput.value;
      addPreferredCity(value);
    };

    const coercePreferredCities = (value) => {
      if (Array.isArray(value)) {
        return dedupePreferredCities(value).slice(0, maxPreferredCities);
      }
      if (typeof value === 'string' && value.trim()) {
        const parts = value.split(/[,;\n|\/]+/);
        return dedupePreferredCities(parts).slice(0, maxPreferredCities);
      }
      return [];
    };

    const setPreferredCities = (cities) => {
      selectedPreferredCities = dedupePreferredCities(Array.isArray(cities) ? cities : []).slice(
        0,
        maxPreferredCities
      );
      renderPreferredCityChips();
      updatePreferredCityInputState();
      if (preferredCityDropdownOpen || (preferredCityInput && document.activeElement === preferredCityInput)) {
        renderPreferredCityOptions(preferredCityInput?.value || '');
      } else if (preferredCityOptionsEl) {
        preferredCityOptionsEl.innerHTML = '';
        preferredCityFilteredOptions = [];
        preferredCityActiveIndex = -1;
        preferredCityInput?.removeAttribute('aria-activedescendant');
      }
    };

    const getPreferredCities = () => selectedPreferredCities.slice();

    preferredCityInput?.addEventListener('focus', () => {
      if (selectedPreferredCities.length >= maxPreferredCities) return;
      renderPreferredCityOptions(preferredCityInput.value);
      openPreferredCityDropdown();
    });

    preferredCityInput?.addEventListener('input', (event) => {
      const value = event.target?.value || '';
      renderPreferredCityOptions(value);
    });

    preferredCityInput?.addEventListener('keydown', (event) => {
      if (event.key === 'Backspace' && !preferredCityInput.value && selectedPreferredCities.length) {
        event.preventDefault();
        const last = selectedPreferredCities[selectedPreferredCities.length - 1];
        removePreferredCity(last);
        return;
      }
      if (event.key === 'ArrowDown') {
        event.preventDefault();
        if (!preferredCityFilteredOptions.length) return;
        const next = preferredCityActiveIndex + 1;
        const capped = next >= preferredCityFilteredOptions.length ? 0 : next;
        highlightPreferredCityOption(capped);
        return;
      }
      if (event.key === 'ArrowUp') {
        event.preventDefault();
        if (!preferredCityFilteredOptions.length) return;
        const next = preferredCityActiveIndex - 1;
        const capped = next < 0 ? preferredCityFilteredOptions.length - 1 : next;
        highlightPreferredCityOption(capped);
        return;
      }
      if (event.key === 'Enter') {
        event.preventDefault();
        if (preferredCityActiveIndex >= 0 && preferredCityActiveIndex < preferredCityFilteredOptions.length) {
          addPreferredCity(preferredCityFilteredOptions[preferredCityActiveIndex].value);
        } else {
          commitPreferredCityInput();
        }
        return;
      }
      if (event.key === 'Escape') {
        closePreferredCityDropdown();
      }
    });

    preferredCityOptionsEl?.addEventListener('mousedown', (event) => {
      // Prevent the input from losing focus before we handle selection.
      event.preventDefault();
    });

    preferredCityOptionsEl?.addEventListener('click', (event) => {
      const target = event.target;
      if (!target || !(target instanceof HTMLElement)) return;
      const value = target.dataset?.value;
      if (!value) return;
      addPreferredCity(value);
      preferredCityInput?.focus();
    });

    document.addEventListener('click', (event) => {
      if (!preferredCityField) return;
      if (preferredCityField.contains(event.target)) return;
      closePreferredCityDropdown();
    });

    renderPreferredCityChips();
    updatePreferredCityInputState();
    setPreferredCityError('');

    const setCurrentCTCError = (message) => {
      if (!currentCTCErrorEl) return;
      const text = typeof message === 'string' ? message.trim() : '';
      currentCTCErrorEl.textContent = text;
      if (text) {
        currentCTCErrorEl.classList.remove('hidden');
        currentCTCInput?.setAttribute('aria-invalid', 'true');
      } else {
        currentCTCErrorEl.classList.add('hidden');
        currentCTCInput?.removeAttribute('aria-invalid');
      }
    };

    const normalizeCurrentCTCValue = (raw) => {
      if (raw === undefined || raw === null) return undefined;
      if (typeof raw === 'number' && Number.isFinite(raw)) return raw;
      const trimmed = String(raw).trim();
      if (!trimmed) return undefined;
      const digits = trimmed.replace(/\D+/g, '');
      if (!digits) return undefined;
      const numeric = Number.parseInt(digits, 10);
      return Number.isFinite(numeric) ? numeric : undefined;
    };

    const setCurrentCTCFieldValue = (value) => {
      if (!currentCTCInput) return;
      const normalized = normalizeCurrentCTCValue(value);
      currentCTCInput.value = normalized === undefined ? '' : String(normalized);
    };

    currentCTCInput?.addEventListener('input', () => {
      const rawValue = currentCTCInput.value;
      const digits = rawValue.replace(/\D+/g, '');
      if (rawValue !== digits) {
        currentCTCInput.value = digits;
      }
      if (!digits && rawValue !== '') {
        setCurrentCTCError('Current CTC must be digits only, e.g., 1800000.');
      } else if (digits) {
        setCurrentCTCError('');
      }
    });

    setCurrentCTCError('');

    const curatedRoleGroups = [
      {
        label: "Product, Design & Strategy",
        options: [
          "Product Manager",
          "Associate Product Manager",
          "Senior Product Manager",
          "Product Owner / Scrum Lead",
          "Product Analyst",
          "Systems Analyst",
          "UX / UI Designer",
          "Product Designer",
          "UX Researcher",
          "Design Lead / Creative Director",
          "Business Analyst",
          "Strategy / Management Consultant"
        ]
      },
      {
        label: "Engineering & Technology (Software)",
        options: [
          "Frontend Developer",
          "Backend Developer",
          "Full-Stack Developer",
          "Software Engineer",
          "DevOps / Cloud Engineer",
          "Mobile App Developer",
          "QA Engineer / Test Automation Engineer",
          "Data Engineer",
          "Data Scientist / ML Engineer",
          "AI / Prompt Engineer",
          "Solution Architect",
          "Tech Lead / Engineering Manager"
        ]
      },
      {
        label: "Core Engineering & Manufacturing",
        options: [
          "Mechanical Engineer",
          "Electrical Engineer",
          "Electronics / Instrumentation Engineer",
          "Civil Engineer",
          "Structural Engineer",
          "Chemical Engineer",
          "Production / Manufacturing Engineer",
          "Quality Engineer / QA-QC",
          "Maintenance Engineer",
          "Plant Operations Manager",
          "R&D Engineer / Design Engineer",
          "Industrial Engineer"
        ]
      },
      {
        label: "Data, Analytics & Finance",
        options: [
          "Data Analyst",
          "Business Intelligence (BI) Developer",
          "Financial Analyst",
          "FP&A / Finance Manager",
          "Investment / Equity Analyst",
          "Risk / Credit Analyst"
        ]
      },
      {
        label: "Customer, Operations & Support",
        options: [
          "Customer Success Manager",
          "Client Relationship Manager",
          "Product Support Specialist",
          "Technical Support Engineer",
          "Operations Executive / Operations Manager",
          "Process / Quality Analyst",
          "Project Coordinator / Project Manager",
          "Supply-Chain / Logistics Executive",
          "Procurement / Vendor Manager"
        ]
      },
      {
        label: "Marketing, Sales & Growth",
        options: [
          "Digital Marketing Specialist",
          "Performance Marketing Manager",
          "SEO / Content Strategist",
          "Growth Marketer / Growth PM",
          "Brand Manager",
          "Product Marketing Manager",
          "Sales Executive / Account Executive",
          "Business Development Manager",
          "Inside Sales / Lead Gen Specialist",
          "Key Account Manager",
          "Partnership / Alliances Manager"
        ]
      },
      {
        label: "HR, Talent & Admin",
        options: [
          "HR Executive / HR Manager",
          "Talent Acquisition Specialist",
          "L&D / Training Specialist",
          "People Operations",
          "Office Admin / EA / Operations Coordinator"
        ]
      },
      {
        label: "IT, Security & Infra",
        options: [
          "System Administrator",
          "Network Engineer",
          "IT Support Engineer",
          "Cybersecurity Analyst",
          "Infrastructure Engineer"
        ]
      },
      {
        label: "Education, Content & Training",
        options: [
          "Instructional Designer",
          "Content Writer / Editor",
          "Technical Writer",
          "Trainer / Coach"
        ]
      },
      {
        label: "Others",
        options: [
          "Legal Associate / Compliance Officer",
          "Research Associate",
          "Entrepreneur / Founder / Co-founder"
        ]
      }
    ];
    const curatedRoles = curatedRoleGroups.flatMap((group) => group.options);
    const normalizeRoleString = (value = "") => {
      if (value === null || value === undefined) return "";
      return value
        .toString()
        .toLowerCase()
        .replace(/&/g, "and")
        .replace(/[^a-z0-9]+/g, " ")
        .trim();
    };
    const curatedRoleMeta = curatedRoles.map((value) => ({
      value,
      normalized: normalizeRoleString(value)
    }));
    let filteredRoleOptions = [];
    let activeRoleIndex = -1;
    let isRoleListOpen = false;

    function highlightActiveOption(index) {
      if (!roleInputEl) {
        activeRoleIndex = -1;
        return;
      }
      if (!filteredRoleOptions.length || index < 0 || index >= filteredRoleOptions.length) {
        filteredRoleOptions.forEach(({ element }) => {
          element.classList.remove("is-active");
        });
        roleInputEl.removeAttribute("aria-activedescendant");
        activeRoleIndex = -1;
        return;
      }
      filteredRoleOptions.forEach(({ element }, idx) => {
        if (idx === index) {
          element.classList.add("is-active");
          element.scrollIntoView({ block: "nearest" });
          roleInputEl.setAttribute("aria-activedescendant", element.id);
        } else {
          element.classList.remove("is-active");
        }
      });
      activeRoleIndex = index;
    }

    const renderRoleOptions = (query = "") => {
      if (!roleListEl) return;
      const normalizedQuery = normalizeRoleString(query);
      roleListEl.innerHTML = "";
      filteredRoleOptions = [];
      curatedRoleGroups.forEach((group) => {
        const matches = group.options.filter((option) => {
          if (!normalizedQuery) return true;
          const normalizedOption = normalizeRoleString(option);
          if (normalizedOption.includes(normalizedQuery)) return true;
          const tokens = normalizedQuery.split(" ").filter(Boolean);
          return tokens.every((token) => normalizedOption.includes(token));
        });
        if (!matches.length) return;
        const header = document.createElement("li");
        header.className = "combobox-group";
        header.setAttribute("role", "presentation");
        header.textContent = group.label;
        roleListEl.appendChild(header);
        matches.forEach((option) => {
          const li = document.createElement("li");
          const index = filteredRoleOptions.length;
          li.className = "combobox-option";
          li.setAttribute("role", "option");
          li.dataset.value = option;
          li.dataset.index = String(index);
          li.id = `role-option-${index}`;
          li.textContent = option;
          const isSelected = roleHiddenInput?.value === option;
          li.setAttribute("aria-selected", isSelected ? "true" : "false");
          if (isSelected) li.classList.add("is-selected");
          filteredRoleOptions.push({ value: option, element: li });
          roleListEl.appendChild(li);
        });
      });
      if (!filteredRoleOptions.length) {
        const empty = document.createElement("li");
        empty.className = "combobox-no-results";
        empty.setAttribute("role", "presentation");
        const trimmed = query && query.trim();
        empty.textContent = trimmed
          ? `No matches found. Press Enter to use ‚Äú${trimmed}‚Äù.`
          : "No roles found.";
        roleListEl.appendChild(empty);
      }
      highlightActiveOption(-1);
    };

    const openRoleList = () => {
      if (!roleCombobox || !roleInputEl) return;
      roleCombobox.setAttribute("data-open", "true");
      roleInputEl.setAttribute("aria-expanded", "true");
      isRoleListOpen = true;
    };

    const closeRoleList = ({ commitValue } = {}) => {
      if (!roleCombobox || !roleInputEl) return;
      if (!isRoleListOpen && commitValue !== true) return;
      roleCombobox.removeAttribute("data-open");
      roleInputEl.setAttribute("aria-expanded", "false");
      isRoleListOpen = false;
      highlightActiveOption(-1);
      if (commitValue) {
        commitRoleInput();
      }
    };

    const setRoleValue = (value) => {
      if (!roleHiddenInput || !roleInputEl) return;
      const trimmed = typeof value === "string" ? value.trim() : "";
      roleHiddenInput.value = trimmed;
      roleInputEl.value = trimmed;
      renderRoleOptions(roleInputEl.value);
    };

    const commitRoleInput = () => {
      if (!roleInputEl) return;
      setRoleValue(roleInputEl.value);
    };

    const moveActive = (direction) => {
      if (!filteredRoleOptions.length) return;
      let nextIndex = activeRoleIndex + direction;
      if (nextIndex < 0) nextIndex = filteredRoleOptions.length - 1;
      if (nextIndex >= filteredRoleOptions.length) nextIndex = 0;
      highlightActiveOption(nextIndex);
    };

    const selectActiveOption = () => {
      if (activeRoleIndex >= 0 && activeRoleIndex < filteredRoleOptions.length) {
        const option = filteredRoleOptions[activeRoleIndex];
        setRoleValue(option.value);
      } else {
        commitRoleInput();
      }
      closeRoleList();
      roleInputEl?.focus();
    };

    const levenshteinDistance = (a, b) => {
      const lenA = a.length;
      const lenB = b.length;
      if (lenA === 0) return lenB;
      if (lenB === 0) return lenA;
      const matrix = Array.from({ length: lenA + 1 }, () => new Array(lenB + 1).fill(0));
      for (let i = 0; i <= lenA; i += 1) matrix[i][0] = i;
      for (let j = 0; j <= lenB; j += 1) matrix[0][j] = j;
      for (let i = 1; i <= lenA; i += 1) {
        const charA = a.charCodeAt(i - 1);
        for (let j = 1; j <= lenB; j += 1) {
          const cost = charA === b.charCodeAt(j - 1) ? 0 : 1;
          matrix[i][j] = Math.min(
            matrix[i - 1][j] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j - 1] + cost
          );
        }
      }
      return matrix[lenA][lenB];
    };

    const tokenSimilarity = (a, b) => {
      const tokensA = Array.from(new Set(a.split(" ").filter(Boolean)));
      const tokensB = Array.from(new Set(b.split(" ").filter(Boolean)));
      if (!tokensA.length || !tokensB.length) return 0;
      const intersection = tokensB.filter((token) => tokensA.includes(token)).length;
      return (2 * intersection) / (tokensA.length + tokensB.length);
    };

    const bestCuratedRoleFor = (raw) => {
      const normalizedTarget = normalizeRoleString(raw);
      if (!normalizedTarget) return null;
      let bestMatch = null;
      curatedRoleMeta.forEach((entry) => {
        if (!entry.normalized) return;
        let score = 0;
        if (entry.normalized === normalizedTarget) {
          score = 1;
        } else {
          if (
            entry.normalized.includes(normalizedTarget) ||
            normalizedTarget.includes(entry.normalized)
          ) {
            score = Math.max(score, 0.94);
          }
          const maxLength = Math.max(entry.normalized.length, normalizedTarget.length);
          if (maxLength > 0) {
            const similarity = 1 - levenshteinDistance(entry.normalized, normalizedTarget) / maxLength;
            score = Math.max(score, similarity);
          }
          const tokenScore = tokenSimilarity(entry.normalized, normalizedTarget);
          if (tokenScore > 0) {
            score = Math.max(score, Math.min(0.97, tokenScore));
          }
        }
        if (!bestMatch || score > bestMatch.score) {
          bestMatch = { value: entry.value, score, target: raw };
        }
      });
      return bestMatch;
    };

    const findBestRoleMatchFromList = (candidates = []) => {
      if (!Array.isArray(candidates)) return null;
      let best = null;
      candidates.forEach((candidate) => {
        if (typeof candidate !== "string") return;
        const trimmed = candidate.trim();
        if (!trimmed) return;
        const suggestion = bestCuratedRoleFor(trimmed);
        if (!suggestion || !suggestion.value) return;
        if (!best || suggestion.score > best.score) {
          best = suggestion;
        }
      });
      return best;
    };

    if (roleInputEl && roleListEl) {
      renderRoleOptions("");
      roleInputEl.addEventListener("focus", () => {
        renderRoleOptions(roleInputEl.value);
        openRoleList();
      });
      roleInputEl.addEventListener("click", () => {
        renderRoleOptions(roleInputEl.value);
        openRoleList();
      });
      roleInputEl.addEventListener("input", () => {
        if (roleHiddenInput) {
          roleHiddenInput.value = roleInputEl.value.trim();
        }
        renderRoleOptions(roleInputEl.value);
        openRoleList();
      });
      roleInputEl.addEventListener("keydown", (event) => {
        if (event.key === "ArrowDown") {
          event.preventDefault();
          if (!isRoleListOpen) {
            renderRoleOptions(roleInputEl.value);
            openRoleList();
          }
          moveActive(1);
        } else if (event.key === "ArrowUp") {
          event.preventDefault();
          if (!isRoleListOpen) {
            renderRoleOptions(roleInputEl.value);
            openRoleList();
          }
          moveActive(-1);
        } else if (event.key === "Enter") {
          event.preventDefault();
          selectActiveOption();
        } else if (event.key === "Escape") {
          event.preventDefault();
          closeRoleList({ commitValue: false });
        }
      });
      roleInputEl.addEventListener("blur", () => {
        setTimeout(() => {
          if (!roleCombobox?.contains(document.activeElement)) {
            closeRoleList({ commitValue: true });
          }
        }, 120);
      });
    }

    if (roleListEl) {
      const preventBlur = (event) => {
        event.preventDefault();
      };
      roleListEl.addEventListener("mousedown", preventBlur);
      roleListEl.addEventListener("pointerdown", preventBlur);
      roleListEl.addEventListener("click", (event) => {
        const option = event.target.closest(".combobox-option");
        if (!option || option.hasAttribute("aria-disabled")) return;
        const value = option.dataset.value || "";
        setRoleValue(value);
        closeRoleList();
        roleInputEl?.focus();
      });
      roleListEl.addEventListener("mousemove", (event) => {
        const option = event.target.closest(".combobox-option");
        if (!option) return;
        const index = Number(option.dataset.index);
        if (!Number.isNaN(index)) {
          highlightActiveOption(index);
        }
      });
    }

    document.addEventListener("click", (event) => {
      if (!roleCombobox?.contains(event.target)) {
        closeRoleList({ commitValue: true });
      }
    });

    const notify = (message, options) => {
      if (window.JobSprintUI && typeof window.JobSprintUI.showToast === 'function') {
        return window.JobSprintUI.showToast(message, options || {});
      }
      return null;
    };

    const notifyLoading = (message, options) => {
      if (window.JobSprintUI && typeof window.JobSprintUI.showLoadingToast === 'function') {
        return window.JobSprintUI.showLoadingToast(message, options || {});
      }
      return null;
    };

    const redirectWithToast = (url, message) => {
      const toast = notifyLoading(message || 'Redirecting‚Ä¶');
      setTimeout(() => {
        toast?.update?.('Almost there‚Ä¶');
        window.location.href = url;
      }, 180);
    };

    const readStoredProfile = () => {
      try {
        const raw = localStorage.getItem('jobsprint_profile');
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === 'object' ? parsed : {};
      } catch (err) {
        console.warn('Could not parse stored profile', err);
        return {};
      }
    };

    const writeStoredProfile = (profile) => {
      try {
        localStorage.setItem('jobsprint_profile', JSON.stringify(profile || {}));
      } catch (err) {
        console.warn('Could not sync profile to localStorage', err);
      }
    };

    const getStoredToken = () => {
      const stored = readStoredProfile();
      const token = stored?.token;
      if (typeof token === 'string' && token.trim()) {
        return token.trim();
      }
      return null;
    };

    const hasSeenReadiness = () => {
      try {
        return Boolean(localStorage.getItem('jobsprint_readiness_seen'));
      } catch (err) {
        console.warn('Could not read readiness flag', err);
        return false;
      }
    };

    const updateWorkspaceShortcutVisibility = ({ profileComplete, storedProfile } = {}) => {
      if (!backToWorkspaceBtn) return;
      const readinessSeen = hasSeenReadiness();
      const storedComplete = storedProfile?.profile_complete === true;
      if (readinessSeen || profileComplete === true || storedComplete) {
        backToWorkspaceBtn.classList.remove('hidden');
      } else {
        backToWorkspaceBtn.classList.add('hidden');
      }
    };

    const redirectToWorkspace = () => {
      const token = getStoredToken();
      const destination = token ? `/workspace.html?u=${encodeURIComponent(token)}` : '/workspace.html';
      redirectWithToast(destination, 'Opening your workspace‚Ä¶');
    };

    backToWorkspaceBtn?.addEventListener('click', redirectToWorkspace);

    const initialStoredProfile = readStoredProfile();
    let storedProfileGoogleId = initialStoredProfile?.google_id || null;
    let sessionHasParsedResume = false;
    let hasCompletedOnboarding =
      initialStoredProfile?.profile_complete === true ||
      initialStoredProfile?.onboarding_step === 'done';
    let resumeOnFile = Boolean(initialStoredProfile?.resume_url);
    const shouldHydratePersonalFields = () =>
      sessionHasParsedResume || hasCompletedOnboarding || resumeOnFile;
    const applyPersonalFields = (fields, { force } = {}) => {
      if (!fields || typeof fields !== 'object') return;
      const allow = force === true || shouldHydratePersonalFields();
      if (!allow) return;
      const fieldMap = {
        name: 'name',
        email: 'email',
        phone: 'phone'
      };
      Object.entries(fieldMap).forEach(([key, id]) => {
        const value = fields[key];
        if (value === undefined || value === null || value === '') return;
        const el = document.getElementById(id);
        if (el) {
          el.value = value;
        }
      });
      if (fields && (fields.preferred_cities !== undefined || fields.city !== undefined || force === true)) {
        const preferred = coercePreferredCities(fields.preferred_cities ?? fields.city);
        setPreferredCities(preferred);
      }
    };
    updateWorkspaceShortcutVisibility({ storedProfile: initialStoredProfile });

    if (!googleId && storedProfileGoogleId) {
      googleId = storedProfileGoogleId;
    }

    if (!googleId) {
      if (finishBtn) {
        finishBtn.disabled = true;
        finishBtn.innerText = 'Redirecting...';
        finishBtn.style.opacity = '0.6';
        finishBtn.style.cursor = 'not-allowed';
      }
      notify('Please sign in with Google to finish onboarding. Redirecting you to sign-up.', { variant: 'warning' });
      const redirectParams = new URLSearchParams();
      if (paymentId) redirectParams.set('payment_id', paymentId);
      const emailParam = params.get('email');
      if (emailParam) redirectParams.set('email', emailParam);
      const redirectQuery = redirectParams.toString();
      const redirectUrl = `/signup.html${redirectQuery ? `?${redirectQuery}` : ''}`;
      redirectWithToast(redirectUrl, 'Taking you to sign-in‚Ä¶');
    }
    let uploadedResume = { path: null, publicUrl: null };

    const resumeStatusEl = document.getElementById('resumeStatus');
    const updateResumeStatus = (url) => {
      if (!resumeStatusEl) return;
      if (url) {
        resumeStatusEl.innerHTML = '';
        resumeStatusEl.append('Resume on file: ');
        const link = document.createElement('a');
        link.href = url;
        link.target = '_blank';
        link.rel = 'noopener noreferrer';
        link.textContent = 'View uploaded resume';
        resumeStatusEl.appendChild(link);
      } else {
        resumeStatusEl.textContent = 'No resume uploaded yet.';
      }
    };

    const populateFromProfile = (profile) => {
      if (!profile || typeof profile !== 'object') {
        updateResumeStatus();
        return;
      }
      const {
        name,
        email,
        phone,
        city,
        preferred_cities,
        dob,
        role,
        experience,
        current_ctc,
        resume_url,
        career_story,
        onboarding_step,
        profile_complete
      } = profile;

      if (profile_complete === true || onboarding_step === 'done') {
        hasCompletedOnboarding = true;
      }
      if (resume_url) {
        resumeOnFile = true;
      }

      const deriveCurrentCtc = (direct, story) => {
        const normalizedDirect = normalizeCurrentCTCValue(direct);
        if (normalizedDirect !== undefined) return normalizedDirect;
        if (!story || typeof story !== 'object') return undefined;
        const directFromStory = story.current_ctc ?? story.currentCTC;
        const normalizedStoryDirect = normalizeCurrentCTCValue(directFromStory);
        if (normalizedStoryDirect !== undefined) {
          return normalizedStoryDirect;
        }
        const comp = story.compensation;
        if (comp && typeof comp === 'object') {
          const options = [comp.current, comp.current_ctc, comp.currentCTC, comp.current_salary, comp.currentSalary];
          for (const option of options) {
            const normalized = normalizeCurrentCTCValue(option);
            if (normalized !== undefined) {
              return normalized;
            }
          }
        }
        return undefined;
      };
      applyPersonalFields({ name, email, phone, city, preferred_cities });
      if (dob) document.getElementById('dob').value = dob;
      if (role) {
        setRoleValue(role);
      } else {
        setRoleValue('');
      }
      if (experience !== undefined && experience !== null && experience !== '') {
        document.getElementById('experience').value = experience;
      }
      const resolvedCtc = deriveCurrentCtc(current_ctc, career_story);
      if (resolvedCtc !== undefined) {
        setCurrentCTCFieldValue(resolvedCtc);
      } else {
        setCurrentCTCFieldValue('');
      }
      setCurrentCTCError('');
      if (career_story && typeof career_story === 'object') {
        if (career_story.journey) document.getElementById('journey').value = career_story.journey;
        if (career_story.strengths) document.getElementById('strengths').value = career_story.strengths;
        if (career_story.flow_state_work) document.getElementById('flow').value = career_story.flow_state_work;
        if (career_story.current_vs_next) document.getElementById('nextRole').value = career_story.current_vs_next;
        if (career_story.long_term_vision) document.getElementById('vision').value = career_story.long_term_vision;
      }
      if (resume_url) {
        uploadedResume = { path: resume_url, publicUrl: resume_url };
        updateResumeStatus(resume_url);
      } else {
        uploadedResume = { path: null, publicUrl: null };
        updateResumeStatus();
      }
    };

    const loadExistingProfile = async (id) => {
      if (!id) {
        updateResumeStatus();
        return;
      }
      if (resumeStatusEl) {
        resumeStatusEl.textContent = 'Checking saved resume...';
      }
      try {
        const response = await fetch(`/api/get-user?google_id=${encodeURIComponent(id)}`);
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          console.error('Failed to fetch profile', payload);
          updateResumeStatus();
          return;
        }
        if (!payload?.found) {
          updateResumeStatus();
          return;
        }
        populateFromProfile(payload);
        try {
          const { found, ...rest } = payload;
          const existing = readStoredProfile();
          const merged = { ...existing, ...rest, google_id: id };
          writeStoredProfile(merged);
        } catch (storageErr) {
          console.warn('Could not sync profile to localStorage', storageErr);
        }
        updateWorkspaceShortcutVisibility({ profileComplete: payload?.profile_complete === true });
      } catch (err) {
        console.error('Failed to load existing profile', err);
        updateResumeStatus();
      }
    };

    if (googleId) {
      loadExistingProfile(googleId);
    } else {
      updateResumeStatus();
    }

    // Step navigation
    const step1 = document.getElementById('step1');
    const step2 = document.getElementById('step2');
    document.getElementById('nextBtn').onclick = () => {
      step1.classList.add('hidden');
      step2.classList.remove('hidden');
      window.scrollTo({top:0,behavior:'smooth'});
    };
    document.getElementById('backBtn').onclick = () => {
      step2.classList.add('hidden');
      step1.classList.remove('hidden');
      window.scrollTo({top:0,behavior:'smooth'});
    };

    // Simulate resume parsing
    document.getElementById('resume_file').addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const fd = new FormData();
    fd.append('file', file);
    if (googleId) fd.append('google_id', googleId);
    const emailFromParams = params.get('email') || document.getElementById('email').value.trim();
    if (emailFromParams) fd.append('email', emailFromParams);

    const parsingToast = notifyLoading('Parsing your resume‚Ä¶');
    try {
      const r = await fetch('/api/parse-resume', { method: 'POST', body: fd });
      const j = await r.json();
      if (!r.ok || !j.success) {
        parsingToast?.dismiss?.();
        const reason = j?.detail || j?.error || 'Use PDF/DOCX or fill manually.';
        notify(`Could not parse resume. ${reason}`, { variant: 'danger' });
        return;
      }
      const f = j.fields || {};
      const resumeMeta = j.resume || {};
      uploadedResume = {
        path: resumeMeta.path || null,
        publicUrl: resumeMeta.public_url || null
      };
      const uploadedUrl = uploadedResume.publicUrl || uploadedResume.path || null;
      updateResumeStatus(uploadedUrl);
      if (uploadedUrl) {
        resumeOnFile = true;
      }
      sessionHasParsedResume = true;
      applyPersonalFields({
        name: f.name,
        email: f.email,
        phone: f.phone,
        city: f.city,
        preferred_cities: f.preferred_cities
      }, { force: true });
      if (f.dob) document.getElementById('dob').value = f.dob;
      const candidateTitles = new Set();
      if (typeof f.role === 'string') candidateTitles.add(f.role);
      if (Array.isArray(f.roles)) f.roles.forEach((title) => candidateTitles.add(title));
      if (Array.isArray(f.titles)) f.titles.forEach((title) => candidateTitles.add(title));
      if (Array.isArray(j?.parsed?.roles)) j.parsed.roles.forEach((title) => candidateTitles.add(title));
      if (Array.isArray(j?.parsed?.titles)) j.parsed.titles.forEach((title) => candidateTitles.add(title));
      if (Array.isArray(j?.parsed?.positions)) {
        j.parsed.positions.forEach((position) => {
          if (typeof position === 'string') {
            candidateTitles.add(position);
          } else if (position && typeof position.title === 'string') {
            candidateTitles.add(position.title);
          }
        });
      }
      const bestRoleMatch = findBestRoleMatchFromList(Array.from(candidateTitles));
      if (bestRoleMatch && bestRoleMatch.score >= 0.72) {
        console.info('Matched resume role to curated option', bestRoleMatch);
        setRoleValue(bestRoleMatch.value);
      } else if (typeof f.role === 'string' && f.role.trim()) {
        setRoleValue(f.role);
      }
      if (typeof f.experience === 'number') document.getElementById('experience').value = f.experience;

      const confidence = f._confidence || j.parsed?._confidence;
      const profileHints = f.profiles || j.parsed?.profiles;
      console.info('Resume parse confidence', confidence);
      if (profileHints?.linkedin) console.info('LinkedIn detected:', profileHints.linkedin);
      if (profileHints?.github) console.info('GitHub detected:', profileHints.github);

      parsingToast?.dismiss?.();
      notify('‚ú® Resume parsed with advanced heuristics! Review and adjust if needed.', { variant: 'success' });
    }
    catch (err)
    {
      parsingToast?.dismiss?.();
      console.error(err);
      notify('Parsing failed. Please fill fields manually.', { variant: 'danger' });
    }
});
       
    // document.getElementById('resume_file').addEventListener('change', () => {
    //   setTimeout(() => {
    //     document.getElementById('name').value = "Alex Jobseeker";
    //     document.getElementById('email').value = "alex@example.com";
    //     document.getElementById('phone').value = "+91 9876543210";
    //     setPreferredCities(['Bengaluru']);
    //     document.getElementById('dob').value = "1996-05-12";
    //     document.getElementById('role').value = "Product Manager";
    //     document.getElementById('experience').value = 5;
    //     alert("‚ú® Resume parsed successfully! Dummy data filled.");
    //   }, 800);
    // });

    // Finish onboarding
    document.getElementById('finishBtn').onclick = async () => {
      const google_id = googleId;
      const payment_id = paymentId;
      const emailInput = document.getElementById('email').value.trim();
      const emailParam = params.get('email');
      const email = emailInput || (emailParam ? emailParam.trim() : '');
      const name = document.getElementById('name').value.trim();
      const dobValue = document.getElementById('dob').value.trim();

      if (!google_id) {
        notify('Please sign in with Google to finish onboarding.', { variant: 'danger' });
        finishBtn.disabled = false;
        finishBtn.innerText = "Finish Setup";
        return;
      }
      if (!email) {
        notify('Please add your email so we can keep in touch.', { variant: 'danger' });
        finishBtn.disabled = false;
        finishBtn.innerText = "Finish Setup";
        return;
      }
      if (!name) {
        notify('Please share your full name so we can personalize your workspace.', { variant: 'danger' });
        return;
      }
      if (!dobValue) {
        notify('Please provide your date of birth so we can finalize your profile.', { variant: 'danger' });
        return;
      }
      if (Number.isNaN(Date.parse(dobValue))) {
        notify('Your date of birth looks invalid. Please use the format YYYY-MM-DD.', { variant: 'danger' });
        return;
      }

      const normalize = (value) => {
        const trimmed = typeof value === 'string' ? value.trim() : value;
        return trimmed === '' || trimmed === undefined ? undefined : trimmed;
      };

      const phone = normalize(document.getElementById('phone').value);
      const preferredCities = getPreferredCities();
      const role = normalize(document.getElementById('role').value);
      const experienceRaw = document.getElementById('experience').value;
      const experience = experienceRaw === '' ? undefined : Number(experienceRaw);
      let currentCTC;
      if (currentCTCInput) {
        const rawCurrentCTC = currentCTCInput.value;
        if (rawCurrentCTC && rawCurrentCTC.trim() !== '') {
          const digitsOnly = rawCurrentCTC.replace(/\D+/g, '');
          const numericCTC = normalizeCurrentCTCValue(digitsOnly);
          if (numericCTC === undefined) {
            const message = 'Current CTC must be digits only, e.g., 1800000.';
            setCurrentCTCError(message);
            notify(message, { variant: 'danger' });
            currentCTCInput.focus();
            return;
          }
          currentCTC = numericCTC;
          currentCTCInput.value = String(numericCTC);
          setCurrentCTCError('');
        } else {
          setCurrentCTCError('');
        }
      }
      if (experience !== undefined && Number.isNaN(experience)) {
        notify('Total experience must be a number.', { variant: 'danger' });
        return;
      }

      const careerStoryEntries = {
        journey: normalize(document.getElementById('journey').value),
        strengths: normalize(document.getElementById('strengths').value),
        flow_state_work: normalize(document.getElementById('flow').value),
        current_vs_next: normalize(document.getElementById('nextRole').value),
        long_term_vision: normalize(document.getElementById('vision').value)
      };
      const career_story = Object.fromEntries(
        Object.entries(careerStoryEntries).filter(([, value]) => value !== undefined)
      );

      const payload = {
        google_id,
        email,
        name,
        payment_id,
        dob: dobValue,
        plan_start: new Date().toISOString().slice(0,10),
        plan_end: new Date(Date.now() + 90*24*60*60*1000).toISOString().slice(0,10),
        profile_complete: true,
        onboarding_step: 'done'
      };

      if (phone !== undefined) payload.phone = phone;
      payload.preferred_cities = preferredCities;
      if (role !== undefined) payload.role = role;
      if (experience !== undefined) payload.experience = experience;
      if (currentCTC !== undefined) payload.current_ctc = currentCTC;

      const resumeUrl = uploadedResume.publicUrl || uploadedResume.path || undefined;
      if (resumeUrl) payload.resume_url = resumeUrl;

      if (Object.keys(career_story).length > 0) {
        payload.career_story = career_story;
      }

      finishBtn.disabled = true;
      finishBtn.innerText = "Saving...";

      let savingToast = null;
      try {
        savingToast = notifyLoading('Saving your onboarding‚Ä¶');
        const resp = await fetch('/api/create-user', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify(payload)
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok || !data.success) {
          console.error(data);
          const detailMessage = data?.detail || data?.error;
          const message = detailMessage ? `Could not save your onboarding. ${detailMessage}` : 'Could not save your onboarding. Please try again.';
          savingToast?.dismiss?.();
          notify(message, { variant: 'danger' });
          finishBtn.disabled = false;
          finishBtn.innerText = "Finish Setup";
          return;
        }
        savingToast?.dismiss?.();
        try {
          const existing = readStoredProfile();
          const storageUpdate = { google_id };
          Object.entries(payload).forEach(([key, value]) => {
            if (value !== undefined) {
              storageUpdate[key] = value;
            }
          });
          if (data.token) {
            storageUpdate.token = data.token;
          }
          const mergedProfile = { ...existing, ...storageUpdate };
          if (Array.isArray(storageUpdate.preferred_cities)) {
            delete mergedProfile.city;
          }
          writeStoredProfile(mergedProfile);
          hasCompletedOnboarding = true;
          if (payload.resume_url) {
            resumeOnFile = true;
          }
          updateWorkspaceShortcutVisibility({ storedProfile: mergedProfile });
        } catch (storageErr) {
          console.warn('Could not update stored profile after onboarding', storageErr);
        }
        try {
          localStorage.setItem('jobsprint_readiness_seen', new Date().toISOString());
        } catch (flagErr) {
          console.warn('Could not mark readiness after onboarding', flagErr);
        }
        updateWorkspaceShortcutVisibility({ profileComplete: true });
        notify('üéâ Onboarding complete! Redirecting...', { variant: 'success' });
        redirectWithToast(data.redirect_url || "/sprint-readiness.html", 'Preparing your sprint readiness‚Ä¶');
      } catch (err) {
        console.error(err);
        savingToast?.dismiss?.();
        notify('Something went wrong. Please try again.', { variant: 'danger' });
        finishBtn.disabled = false;
        finishBtn.innerText = "Finish Setup";
      }
    };
  </script>
</body>
</html>
